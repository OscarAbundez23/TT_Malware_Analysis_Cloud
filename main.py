import sys, os, subprocess, json, r2pipe, graphviz
import math, time, multiprocessing,re

global ruta_sample, ruta_resultados, ruta_plantilla

def checarExistenciaRuta(ruta):
    if os.path.exists(ruta):
        return True
    return False

def obtenerResultadoComandos(comando, ruta_archivo_resultado):
    comando.append(ruta_sample)
    tmp = subprocess.run(comando,capture_output=True, text=True)
    resultado = tmp.stdout
    archivo_resultado = open(ruta_archivo_resultado, "w")
    archivo_resultado.write(resultado)
    archivo_resultado.close()
    #return resultado

def ejecutar_comandos_Linux(comando, ruta_carpeta_resultados):
    if comando == "metadata":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/file_"+".txt"
        obtenerResultadoComandos(["file" ], ruta_archivo_resultado)

        ruta_archivo_resultado = ruta_carpeta_resultados+"/exiftool_"+".txt"
        obtenerResultadoComandos(["exiftool" ], ruta_archivo_resultado)

    if comando == "hashes":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/md5_"+".txt"
        obtenerResultadoComandos(["md5sum" ], ruta_archivo_resultado)

        ruta_archivo_resultado = ruta_carpeta_resultados+"/sha1_"+".txt"
        obtenerResultadoComandos(["sha1sum" ], ruta_archivo_resultado)

        ruta_archivo_resultado = ruta_carpeta_resultados+"/sha256_"+".txt"
        obtenerResultadoComandos(["sha256sum" ], ruta_archivo_resultado)

    if comando == "strings":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/strings_"+".txt"
        obtenerResultadoComandos(["strings" ], ruta_archivo_resultado)
        
    if comando == "hexa":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/hexa_"+".txt"
        obtenerResultadoComandos(["hexdump","-C"], ruta_archivo_resultado)

    if comando == "libraries":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/libraries_"+".txt"
        obtenerResultadoComandos(["ldd"], ruta_archivo_resultado)

    if comando == "symbols":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/symbols_"+".txt"
        obtenerResultadoComandos(["readelf","--symbols"], ruta_archivo_resultado)

    if comando == "asm":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/asm_"+".txt"
        obtenerResultadoComandos(["objdump","-d"], ruta_archivo_resultado)

    if comando == "ssdeep":
        ruta_archivo_resultado = ruta_carpeta_resultados+"/ssdeep_"+".txt"
        obtenerResultadoComandos(["ssdeep"], ruta_archivo_resultado)

def escribir_resultados(resultado, ruta):
    if checarExistenciaRuta(ruta)==True:
        with open(ruta,"a") as writer:
            #writer.write("\n")
            writer.write(resultado)
    else:
        with open(ruta,"w") as writer:
            #writer.write("\n")
            writer.write(resultado)

def getImports(r2):
    lista_imports=[]
    lista_dicts = r2.cmdj('isj')
    for objeto in lista_dicts:
        lista_imports.append(objeto['flagname'])
    return lista_imports

def crearCFGs_radare2(r2, path_resultados):
    print("\tr2 cfg debug 1")
    funciones = r2.cmdj("aflj")
    path_resultados = path_resultados+"/CFGs"

    lista_imports = getImports(r2)

    try:
        if not os.path.exists(path_resultados):
            os.mkdir(path_resultados)
    except:
        return
    #print("\tr2 cfg debug 2")
    for funcion in funciones:
        nombre_funcion = funcion["name"]

        direccion_funcion = funcion["offset"]
        if nombre_funcion not in lista_imports:
            r2.cmd("s "+nombre_funcion)
            string_dot = r2.cmd("agfd")
            try:
                src = graphviz.Source(string_dot)
                src.render(path_resultados+"/CFG_"+nombre_funcion+"_r2",format="png")
                os.remove(path_resultados+"/CFG_"+nombre_funcion+"_r2")
            except graphviz.backend.execute.CalledProcessError:
                continue
            except:
                continue
    #print("\tdebug 3")        

def nueva_funcion(funcion_actual, lista_llamadas_global, r2, ruta_carpeta_resultados):
    lista_funciones_llamadas=[]
    dict_funcion = next( (obj for obj in lista_llamadas_global if obj['name'] == funcion_actual) , None)
    #print("dict_funcion",dict_funcion)
    #if dict_funcion["imports"] is not None or len(dict_funcion["imports"]) > 0:
    if dict_funcion != None:
        if "imports" in dict_funcion.keys():
            if len(dict_funcion["imports"]) > 0:
                for funcion in dict_funcion["imports"]:
                    if funcion not in lista_imports:
                        lista_funciones_llamadas.append(funcion)
                        res = r2.cmd("pdg @ "+funcion)
                        escribir_resultados(res, ruta_carpeta_resultados+"/decompiled.txt")
    return lista_funciones_llamadas

def ejecutar_comandos_radare2(comandos, ruta_carpeta_resultados):
    try:
        r2 = r2pipe.open(ruta_sample)
        r2.cmd('aaaa 2>/dev/null')
    except:
        pass
    else:
        for comando in comandos:
            if comando=="decompilado":
                print("\tradare2 decompilado")
                global lista_imports
                lista_imports=getImports(r2)

                #Se obtiene todas las funciones en el programa, tanto imports como user defined
                all_func = r2.cmdj('aflj')

                #Se obtiene el diccionario de la función main
                diccionario = next( (d for d in all_func if d.get('name') == 'main') , None)
                if diccionario is not None:
                    #Se obtiene desemsamblado de main
                    res = r2.cmd("pdg @ "+"main")
                else:
                    res="error: la función main no fue identificada"
                escribir_resultados(res, ruta_carpeta_resultados+"/decompiled_r2.txt")
                lista_imports.append("main")

                for funcion in all_func:
                    if funcion not in lista_imports:
                        res = r2.cmd("pdg @ "+funcion["name"])
                        escribir_resultados(res,ruta_carpeta_resultados+"/decompiled_r2.txt")

            if comando=="asm":
                print("\tradare2 decompilado")
                r2.cmd("aflsa")
                time.sleep(6)
                try:
                    #Se obtiene el punto de entrada
                    entry_point = r2.cmdj("iej")[0]["vaddr"]
                except:
                    print("no hay entry_point")
                    #Si no existe el punto de entrada es posible que el archivo sea una librería compartida
                    diccionarios_funciones = r2.cmdj("aflj")
                    for diccionario in diccionarios_funciones[indice:]:
                        nombre_funcion = diccionario["name"]
                        res = r2.cmd("pdf @ "+nombre_funcion)
                        escribir_resultados(res, ruta_carpeta_resultados+"/asm_r2.txt")            
                else:
                    diccionarios_funciones = r2.cmdj("aflj")
                    indice=0
                    for diccionario in diccionarios_funciones:
                        if diccionario["offset"]==entry_point:
                            break
                        indice+=1
                    for diccionario in diccionarios_funciones[indice:]:
                        nombre_funcion = diccionario["name"]
                        res = r2.cmd("pdf @ "+nombre_funcion)
                        escribir_resultados(res, ruta_carpeta_resultados+"/asm_r2.txt")
            if comando=="call_graph":
                print("\tradare2 decompilado")
                try:
                    print("\tdebug 1")
                    res = r2.cmd("agCd")
                    print("\tdebug 2")
                    src = graphviz.Source(res, engine='neato')
                    print("\tdebug 3")
                    src.render(ruta_carpeta_resultados+"/call_graph_r2",format="png")
                    print("\tdebug 4")
                except subprocess.CalledProcessError:
                    print("subprocess.CalledProcessError")
                except graphviz.backend.execute.CalledProcessError:
                    print("graphviz.backend.execute.CalledProcessError")
                except:
                    print("Otro error")

            if comando=="imports":
                res = r2.cmd("ii")
                escribir_resultados(res, ruta_carpeta_resultados+"/imports_r2.txt")

            if comando =="CFG":
                print(comando)
                crearCFGs_radare2(r2, ruta_carpeta_resultados)

def recorrer_carpeta(ruta_carpeta):
    lista_archivos = []
    for directorio_actual,_, archivos in os.walk(ruta_carpeta):
        for archivo in archivos:
            ruta_absoluta = os.path.join(directorio_actual,archivo)
            lista_archivos.append(ruta_absoluta)
    
    return lista_archivos

def calcular_entropia(counted_bytes, total_bytes_read):
    entropia=0
    for i in range(0,256):
        tmp = counted_bytes[i]/total_bytes_read
        if tmp>0:
            entropia += tmp*abs(math.log(tmp,2))
    
    return round(entropia,4)

def getBytesContados(offset_seccion, tamanio_seccion, path_sample):
    with open(path_sample,"rb") as fd:
        fd.seek(offset_seccion)
        counted_bytes=[0]*256
        if tamanio_seccion == None:
            buffer = fd.read()
            total_bytes_read = len(buffer)
        else:
            buffer = fd.read(tamanio_seccion)
            total_bytes_read = tamanio_seccion
        
        for caracter in buffer:
            counted_bytes[caracter] = counted_bytes[caracter]+1
        #entropia = calcular_entropia(counted_bytes, total_bytes_read)
        #return entropia
        return counted_bytes

def proceso_entropia_por_seccion(path_sample):
    r2 = r2pipe.open(path_sample)
    r2.cmd('aaaa 0>/dev/null')

    secciones_importantes = [".init",".plt",".text", ".rodata",".data",".bss"]

    secciones_programa =r2.cmdj("iSj")
    r2.quit()
    diccionario_entropia={}
    for seccion in secciones_programa:
        if seccion["name"] in secciones_importantes:
            offset_seccion = seccion["paddr"]
            tamanio_seccion = seccion["size"]
            if tamanio_seccion > 0:

                counted_bytes = getBytesContados(offset_seccion,tamanio_seccion, path_sample)
                entropia = calcular_entropia(counted_bytes, tamanio_seccion)
                diccionario_entropia[seccion["name"]] = entropia
    return diccionario_entropia

def obtenerEntropia(ruta_carpeta_resultados):
    diccionario_entropia = proceso_entropia_por_seccion(ruta_sample)

    counted_bytes_general = getBytesContados(0,None,ruta_sample)
    diccionario_entropia["Entropia General"] = calcular_entropia(counted_bytes_general, os.path.getsize(ruta_sample))
    return diccionario_entropia

def Obtener_resultados_Otros(comando, ruta_carpeta_resultados):
    if comando == "entropia":
        diccionario_entropia = obtenerEntropia(ruta_carpeta_resultados)
        with open(ruta_carpeta_resultados+"/entropia.json","w") as fd:
            json.dump(diccionario_entropia,fd,indent=4)

def prueba(ruta_sample,plantilla_json,ruta_resultados):
    #print("antes del import")
    import ghidra_handler_module as ghidra_handler
    #print("despues del import")
    ghidra_handler.init_proceso_ghidra(ruta_sample,plantilla_json,ruta_resultados)
def ejecutar_analisis_estatico():
    #ruta_sample, ruta_resultados, ruta_plantilla
    #ejecutar_comandos(ruta_elemento, ruta_resultado, "tmp")
    archivo_estructura_json = open(ruta_plantilla,"r")
    plantilla_json = json.load(archivo_estructura_json)
    archivo_estructura_json.close()

    if "Linux" in plantilla_json.keys():
    #if plantilla_json["Linux"] is not None:
        print("Linux")
        try:
            os.mkdir(ruta_resultados+"/Linux")
        except:
            pass
        for comando in plantilla_json["Linux"]:
            ejecutar_comandos_Linux(comando, ruta_resultados+"/Linux")
    
    if "radare2" in plantilla_json.keys():
        print("radare2")
        try:
            os.mkdir(ruta_resultados+"/radare2")
        except:
            pass
        proceso_r2 = multiprocessing.Process(target=ejecutar_comandos_radare2,args=(plantilla_json["radare2"],ruta_resultados+"/radare2"))
        proceso_r2.start()
        #time.sleep(10)
        proceso_r2.join(420)
        #print("terminó join")
        if proceso_r2.is_alive:
            try:
                proceso_r2.terminate()
                proceso_r2.kill()
            except Exception as e:
                print("Error al intentar eliminar r2 process",e)


    if "Ghidra" in plantilla_json.keys():
        print("Ghidra")
        try:
            os.mkdir(ruta_resultados+"/Ghidra")
        except:
            pass

        proceso_ghidra = multiprocessing.Process(target=prueba,args=(ruta_sample,plantilla_json,ruta_resultados))
        proceso_ghidra.start()
        #time.sleep(10)
        proceso_ghidra.join(480)
        #print("terminó join")
        if proceso_ghidra.is_alive:
            try:
                proceso_ghidra.terminate()
                proceso_ghidra.kill()
            except Exception as e:
                print("Error al intentar eliminar r2 process",e)
    if "Otros" in plantilla_json.keys():
        print("Otros")
        try:
            os.mkdir(ruta_resultados+"/Otros")
        except:
            pass
        for comando in plantilla_json["Otros"]:
            Obtener_resultados_Otros(comando, ruta_resultados+"/Otros")

def determinar_tipo_archivo():
    with open(ruta_sample,"rb") as fd:
        type = fd.read(4)
    type = type.decode("utf-8")
    binary_type=""
    if type[1:] == "ELF":
        type="ELF"
        comando = "/usr/bin/readelf -h {0} grep 'Type:' awk \'{1}\'".format(
            ruta_sample, "{print $2}"
        )
        comando_arr = comando.split(" ")
        salida = subprocess.run(comando_arr[0:3], stdout=subprocess.PIPE,  text=True)
        salida = salida.stdout.split("\n")
        binary_type=""
        if salida[7][2:7]=="Type:":
            binary_type = re.split("\s+",salida[7][2:])[1]
        else:
            for linea in salida:
                if linea[2:7]=="Type:":
                    binary_type=re.split("\s+",salida[7][2:])[1]
    elif type[0:2] == "MZ":
        type = "MZ"
        binary_type=""
    return type, binary_type

def pre_analisis_estatico():
    tipo_archivo, tipo_binario = determinar_tipo_archivo()
    diccionario_info = {}
    diccionario_info["tipo"] = tipo_archivo
    diccionario_info["tipo binario"] = tipo_binario

    return diccionario_info
def getVariablesEntorno():
    sample = os.getenv("PATH_SAMPLE")
    ruta_resultados = os.getenv("PATH_RESULTADO")
    ruta_plantilla_experimento = os.getenv("PATH_PLANTILLA")
    
    return sample, ruta_resultados, ruta_plantilla_experimento

#docker run --name contodo -e PATH_SOURCE="/home/experimento/tmp" -e PATH_RESULTADO="/home/experimento/resultados" -e PATH_PLANTILLA_EXPERIMENTO="" -v D:\Oscar\ESCOM\Redes2.1\DNS:/home/experimento/tmp -v D:\oabun:/home/experimento/resultados
if __name__ == "__main__":
    # Obtener el argumento de la línea de comandos
    rutas_samples=["/home/ubuntu/Muestras/0c395715bfeb8f89959be721cd2f614d2edb260614d5a21e90cc4c142f5d83ad.elf",
                   "/home/ubuntu/Muestras/10d25dd902a46d9c50908390227d971ca2b9ddb782b88c60daed051e2f16c942.elf",
                   "/home/ubuntu/Muestras/1ce6a2c6c5774dae1355cd328f47dfe6102433f7da9407344c8646b44c7ba9be.elf",
                   "/home/ubuntu/Muestras/24b5cdfc8de10c99929b230f0dcbf7fcefe9de448eeb6c75675cfe6c44633073.elf",
                   "/home/ubuntu/Muestras/5c9b30d502e2f103f089607ce699520f88154e3d7988a9db801f2a2a4378bf41.elf",
                   "/home/ubuntu/Muestras/63cceba7384b2a44242598bdb8c9a2f87e455a0a88eaf9aa401fd43fb990b062.elf",
                   "/home/ubuntu/Muestras/6a7b7147fea63d77368c73cef205eb75d16ef209a246b05698358a28fd16e502.elf"]
    ruta_plantilla = "/home/ubuntu/plantillas/plantilla_asm_decomp.json" 
    #="/home/ubuntu/plantilla.json"
    rutas_g="/home/ubuntu/Experimentos"
    conteo=1
    for r in rutas_samples:
        ruta_sample = r
        ruta_resultados = rutas_g+"/Resultados_"+str(conteo)
        os.mkdir(ruta_resultados)
        conteo=conteo+1
        if ruta_sample == None or ruta_resultados == None or ruta_plantilla == None:
            print("Debe proporcionar rutas para los resultados y otra donde se encuentra los archivos a analizar")
            sys.exit(-1)
        if not(checarExistenciaRuta(ruta_plantilla)) or not(checarExistenciaRuta(ruta_sample)) or not(checarExistenciaRuta(ruta_resultados)):
            print("Error de ruta no existente")
        if os.path.splitext(ruta_plantilla)[1] != ".json":
            print("Error, la plantilla de experimento debe ser json") 
            sys.exit(-1)
        diccionario_info_muestra = pre_analisis_estatico()
        if diccionario_info_muestra["tipo"]!="":
            ejecutar_analisis_estatico()

