import sys, os, subprocess, json, r2pipe, graphviz, yara
import math, time, multiprocessing, re

def checarExistenciaRuta(ruta):
    if os.path.exists(ruta):
        return True
    return False

def escribir_resultados(resultado, ruta):
    if checarExistenciaRuta(ruta)==True:
        with open(ruta,"a") as writer:
            writer.write(resultado)
    else:
        with open(ruta,"w") as writer:
            writer.write(resultado)

def getImports(r2):
    lista_imports=[]
    lista_dicts = r2.cmdj('isj')
    for objeto in lista_dicts:
        lista_imports.append(objeto['flagname'])
    return lista_imports

def crearCFGs_radare2(r2, path_resultados, queue):
    print("\tr2 cfg debug 1")
    funciones = r2.cmdj("aflj")
    path_resultados = path_resultados+"/CFGs"

    try:
        if not os.path.exists(path_resultados):
            os.mkdir(path_resultados)
    except:
        return
    contador=0
    for funcion in funciones:
        nombre_funcion = funcion["name"]
        if not nombre_funcion.startswith("sym.imp"):
            try:
                r2.cmd("s "+nombre_funcion)
                string_dot = r2.cmd("agfd")
                src = graphviz.Source(string_dot)
                src.render(path_resultados+"/CFG_"+nombre_funcion+"_r2",format="png")
                os.remove(path_resultados+"/CFG_"+nombre_funcion+"_r2")
            except:
                contador+=1
                continue

    if contador < len(funciones):
        queue.put("CFG")

def nueva_funcion(funcion_actual, lista_llamadas_global, r2, ruta_carpeta_resultados):
    lista_funciones_llamadas=[]
    dict_funcion = next( (obj for obj in lista_llamadas_global if obj['name'] == funcion_actual) , None)
    if dict_funcion != None:
        if "imports" in dict_funcion.keys():
            if len(dict_funcion["imports"]) > 0:
                for funcion in dict_funcion["imports"]:
                    if funcion not in lista_imports:
                        lista_funciones_llamadas.append(funcion)
                        res = r2.cmd("pdg @ "+funcion)
                        escribir_resultados(res, ruta_carpeta_resultados+"/decompiled.txt")
    return lista_funciones_llamadas

def ejecutar_comandos_radare2(comandos, ruta_carpeta_resultados, ruta_sample, queue):
    try:
        r2 = r2pipe.open(ruta_sample)
        r2.cmd('aaaa 2>/dev/null')
    except Exception as e:
        print("Hubo un error,",e)
    else:
        for comando in comandos:
            if comando=="decompilado":
                print("\tradare2 decompilado")
                global lista_imports
                #lista_imports=getImports(r2)
                lista_imports=[]
                #Se obtiene todas las funciones en el programa, tanto imports como user defined
                all_func = r2.cmdj('aflj')

                #Se obtiene el diccionario de la función main
                diccionario = next( (d for d in all_func if d.get('name') == 'main') , None)
                if diccionario is not None:
                    #Se obtiene desemsamblado de main
                    res = r2.cmd("pdg @ "+"main")
                else:
                    res="Función main no fue identificada"
                escribir_resultados(res, ruta_carpeta_resultados+"/decompiled_r2.txt")
                lista_imports.append("main")

                for funcion in all_func:
                    if funcion not in lista_imports and ".imp." not in funcion["name"]:
                        res = r2.cmd("pdg @ "+funcion["name"])
                        escribir_resultados(res,ruta_carpeta_resultados+"/decompiled_r2.txt")
                queue.put("decompilado")
            if comando=="asm":
                print("\tradare2 desensamblado")
                r2.cmd("aflsa")
                time.sleep(6)
                try:
                    #Se obtiene el punto de entrada
                    entry_point = r2.cmdj("iej")[0]["vaddr"]
                except:
                    print("no hay entry_point")
                    #Si no existe el punto de entrada es posible que el archivo sea una librería compartida
                    diccionarios_funciones = r2.cmdj("aflj")
                    for diccionario in diccionarios_funciones[indice:]:
                        nombre_funcion = diccionario["name"]
                        res = r2.cmd("pdf @ "+nombre_funcion)
                        escribir_resultados(res, ruta_carpeta_resultados+"/asm_r2.txt")            
                else:
                    diccionarios_funciones = r2.cmdj("aflj")
                    indice=0
                    for diccionario in diccionarios_funciones:
                        if diccionario["offset"]==entry_point:
                            break
                        indice+=1
                    for diccionario in diccionarios_funciones[indice:]:
                        nombre_funcion = diccionario["name"]
                        res = r2.cmd("pdf @ "+nombre_funcion)
                        escribir_resultados(res, ruta_carpeta_resultados+"/asm_r2.txt")
                queue.put("asm")
            if comando=="call_graph":
                print("\tradare2 call_graph")
                try:
                    res = r2.cmd("agCd")
                    src = graphviz.Source(res)
                    src.render(ruta_carpeta_resultados+"/call_graph_r2",format="png")
                    queue.put("call_graph")
                except subprocess.CalledProcessError:
                    print("subprocess.CalledProcessError")
                except graphviz.backend.execute.CalledProcessError:
                    print("graphviz.backend.execute.CalledProcessError")
                except:
                    print("Otro error")

            if comando=="imports":
                try:
                    res = r2.cmd("ii")
                    escribir_resultados(res, ruta_carpeta_resultados+"/imports_r2.txt")
                    queue.put("imports")
                except:
                    pass
            if comando =="CFG":
                print(comando)
                crearCFGs_radare2(r2, ruta_carpeta_resultados, queue)

            if comando == "strings":
                print(comando)
                try:
                    res = r2.cmd("izz")
                    escribir_resultados(res, ruta_carpeta_resultados+"/strings_r2.txt")
                except:
                    pass