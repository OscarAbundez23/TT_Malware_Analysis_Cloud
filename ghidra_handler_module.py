import sys, os, subprocess, json, r2pipe, graphviz, time, math
import pyhidra
pyhidra.start()
import ghidra
from ghidra.app.util.headless import HeadlessAnalyzer
from ghidra.program.flatapi import FlatProgramAPI
from ghidra.base.project import GhidraProject
from java.lang import String
from ghidra.app.decompiler import DecompInterface
from pyhidra.launcher import HeadlessPyhidraLauncher
from ghidra.app.util.bin import ByteProvider, MemoryByteProvider
from ghidra.app.util.bin.format.elf import ElfHeader

launcher = HeadlessPyhidraLauncher()
launcher.add_classpaths("log4j-core-2.17.1.jar", "log4j-api-2.17.1.jar")
launcher.add_vmargs("-Dlog4j2.formatMsgNoLookups=true")
launcher.start()

DISTANCE_FROM_ADDRESS_TO_BYTE = 15

DISTANCE_FROM_BYTE_TO_INST = 15

MSG_FORMAT = ' {{addr:<{0}}} {{byte:<{1}}} {{inst}}\t{{extra}}\n'.format(
    DISTANCE_FROM_ADDRESS_TO_BYTE,
    DISTANCE_FROM_ADDRESS_TO_BYTE+DISTANCE_FROM_BYTE_TO_INST 
)

MSG_LOCAL_VARIABLES = "\t{datatype} {variablestorage} {name}\n"

def checarExistenciaRuta_2(ruta):
    if os.path.exists(ruta):
        return True
    return False

def escribir_resultados_2(resultado, ruta):
    if checarExistenciaRuta_2(ruta)==True:
        with open(ruta,"a") as writer:
            #writer.write("\n")
            writer.write(resultado)
    else:
        with open(ruta,"w") as writer:
            #writer.write("\n")
            writer.write(resultado)

def unoverflow(x):
    return (abs(x) ^ 0xff) + 1

def to_hex(integer):
	return '{:02x}'.format(integer)

def getCallFunctionName(inst, flat_api):
    currentProgram = flat_api.getCurrentProgram()
    reference_list = inst.getReferencesFrom()
    if reference_list != None:
        if len(reference_list)>0:
            source = reference_list[0].getSource().toString()
            reftype = reference_list[0].getReferenceType().toString()
            if source == "DEFAULT" and reftype=="UNCONDITIONAL_CALL":
                addr_reference = reference_list[0].getToAddress()
                try:
                    funcion_llamada = currentProgram.getListing().getFunctionAt(addr_reference)
                    return funcion_llamada
                except Exception as e:
                    return ""
    return ""

def getParametros(current_function):
    parameters_list = current_function.getParameters()
    cadena=""
    if len(parameters_list)>0:
        cadena+="\tParametros:\n"
        for parameters in parameters_list:
            cadena+= MSG_LOCAL_VARIABLES.format(
                datatype=str(parameters.getFormalDataType()),
                variablestorage=str(parameters.getName()),
                name=str(parameters.getVariableStorage())
            )
    return cadena

def getVariablesLocales(current_function):
    cadena=""
    localVariables_list = current_function.getLocalVariables()
    if len(localVariables_list) >0:
        cadena+="\tVariables Locales:\n"
        for local in localVariables_list:
            cadena+= MSG_LOCAL_VARIABLES.format(
                datatype=str(local.getDataType()),
                variablestorage=str(local.getVariableStorage()),
                name=str(local.getName())
            )
    return cadena

def obtenerDesensambladoGhidra(flat_api, ruta_carpeta_resultados):
    try:
        currentProgram = flat_api.getCurrentProgram()
        byteProvider = MemoryByteProvider(currentProgram.getMemory(), currentProgram.getImageBase())
        header = ElfHeader(byteProvider, None)
        entry_point =header.e_entry()
        addr = flat_api.toAddr(entry_point)
        instructions = currentProgram.getListing().getInstructions(addr, True)
    except:
        return None
    tmp=""
    for inst in instructions:
        pS = inst.getPrimarySymbol() #Esto tambien puede significar los LAB_ que son secciones dentro de la misma funcion
        funcion_llamada = getCallFunctionName(inst, flat_api)
        instruction = inst

        if pS is not None:
            current_function_address = inst.getAddress()
            current_function = currentProgram.getListing().getFunctionAt(current_function_address)
            if current_function is not None:
                function_signature = current_function.getSignature()
                tmp+= "\n\t\t\t\t"+str(function_signature) +"\n"
                tmp+= getParametros(current_function)                  
                tmp+= getVariablesLocales(current_function)

    
        tmp+= MSG_FORMAT.format(
            addr=inst.getAddressString(False, False),
            byte=' '.join([to_hex(b) if b >= 0 else to_hex(unoverflow(b)) for b in inst.getBytes()]),
            inst = instruction,
            extra= funcion_llamada
        )
    escribir_resultados_2(tmp,ruta_carpeta_resultados+"/desensamblado_ghidra.txt")
    return 1

def crearCallGraphs_Ghidra(flat_api, ruta_carpeta_resultados):
    print("\tghidra call graph debug 1")
    try:
        prog = flat_api.getCurrentProgram()  
        sm = prog.getSymbolTable()
    except:
        return None
    externalSymbols=[]
    all_symb = sm.getExternalSymbols()
    for s in all_symb:
        externalSymbols.append("<EXTERNAL>::"+str(s))
    try:
        exportAddrs = sm.getExternalEntryPointIterator()
    except:
        return None
    imports=[]
    for addr in exportAddrs:
        sym = sm.getPrimarySymbol(addr)
        if(sym is not None):
            imports.append(str(sym.getName()))

    all_funcs = prog.functionManager.getFunctions(True)
    graph_Attributes = {'bgcolor': 'azure', 'fontname':'Courier', 'splines':'curved', 'nslimit':'0','nslimit1':'2'}
    node_Atrributes = {'style': 'filled','fontname': 'Courier Bold', 'penwidth':'4', 'fillcolor':'white'}
    edge_Attributes = {'arrowhead':"normal", 'color':'#61afef' ,'style': 'bold', 'weight':'2'}
    try:
        f = graphviz.Digraph("Call_Graph", format="png",filename="Call_graph", node_attr=node_Atrributes, edge_attr=edge_Attributes, graph_attr=graph_Attributes)
        f.attr(rankdir='LR')
        f.attr(outputorder="edgesfirst")
    except:
        return None
    lista=[]
    diccionario={}
    for funcion in all_funcs:
        if funcion.getName() not in lista:
            f.node(funcion.getName())
            lista.append(funcion.getName())
        for called_function in funcion.getCalledFunctions(None):
            if called_function.getName() not in lista:
                f.node(called_function.getName())
                lista.append(called_function.getName())
            f.edge(funcion.getName(), called_function.getName())
    try:
        f.render(directory=ruta_carpeta_resultados)
        return 1
    except:
        return None

def obtenerDecompilado_Ghidra(flat_api, ruta_carpeta_resultados):
    nonrequiredfunctions=[]
    try:
        prog = flat_api.getCurrentProgram()
        sm = prog.getSymbolTable()
        all_symb = sm.getExternalSymbols()
    except:
        return None
    for s in all_symb:
        nonrequiredfunctions.append("<EXTERNAL>::"+str(s))

    exportAddrs = sm.getExternalEntryPointIterator()
    for addr in exportAddrs:
        sym = sm.getPrimarySymbol(addr)
        if(sym is not None):
            nonrequiredfunctions.append(str(sym.getName()))
    try:
        decompiler = DecompInterface()
        decompiler.openProgram(prog)
        all_funcs = prog.functionManager.getFunctions(True)
    except:
        return None

    for function in all_funcs:
        if str(function) not in nonrequiredfunctions:
            res = decompiler.decompileFunction(function,0,None)
            if res.decompileCompleted() == True:
                if res.decompileCompleted() == True:
                    dec = res.getDecompiledFunction()
                    if dec:
                        escribir_resultados_2(dec.getC(),ruta_carpeta_resultados+"/decompiled_ghidra.txt")
    return 1


def ejecutar_comandos_Ghidra(comandos, ruta_carpeta_resultados, flat_api, queueIPC):
    for comando in comandos:
        if comando == "decompilado":
            print("\tGhidra decompilado")
            res = obtenerDecompilado_Ghidra(flat_api, ruta_carpeta_resultados)
            if res == 1:
                queueIPC.put(comando)
        if comando == "call_graph":
            print("\tGhidra",comando)
            try:
                res = crearCallGraphs_Ghidra(flat_api,ruta_carpeta_resultados)
                if res == 1:
                    queueIPC.put(comando)
            except Exception as error:
                print("Error,",error)
        if comando == "asm":
            print("\tGhidra",comando)
            try: 
                res = obtenerDesensambladoGhidra(flat_api, ruta_carpeta_resultados)
                if res == 1:
                    queueIPC.put(comando)
            except Exception as error:
                print("Error ",error)

def init_proceso_ghidra(ruta_sample, plantilla_json, ruta_resultados, queueIPC):
    with pyhidra.open_program(ruta_sample) as flat_api:
        ejecutar_comandos_Ghidra(plantilla_json["Ghidra"],ruta_resultados+"/Ghidra",flat_api, queueIPC)
